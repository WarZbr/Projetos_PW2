// Recebe uma lista numérica e retorna uma lista cujos valores foram multiplicados por 2.
// Deve ser implementada usando map/filter/reduce
function dobro(valores) {
  return valores
      .map(valor => valor * 2)                 // Multiplica cada valor por 2
      .filter(valor => valor !== undefined)    // Mantém todos os valores (não filtra nada de fato)
      .reduce((acumulador, valor) => {
          acumulador.push(valor);              // Adiciona cada valor ao acumulador
          return acumulador;
      }, []);                                  // Começa com um array vazio
}





// Recebe duas listas e retorna uma lista com a união das listas de entrada, sem repetições.
function uniao(v1, v2) {    
  let resultado = v1.concat(v2);

  let unicos = [];
  resultado.forEach(item => {
      if (!unicos.includes(item)) {
          unicos.push(item);
      }
  });

  return unicos;
   
}

function uniao(v1, v2) {
    const resultado = [...v1];
  
    for (let i = 0; i < v2.length; i++) {
      if (!resultado.includes(v2[i])) {
        resultado.push(v2[i]);
      }
    }
  
    return resultado;
  }


function uniao(v1, v2) {
 
  const resultado = [...v1];
  
  v2.forEach(item => {
      if (!resultado.includes(item)) {
          resultado.push(item);
      }
  });

  return resultado;
}

// Função que recebe duas listas e retorna os elementos da primeira lista que não estejam na segunda lista.
function diff(v1, v2) {
  return v1.filter(item => !v2.includes(item));

}

/*
    Recebe duas listas numéricas e retorna o vetor cuja soma dos valores é maior que a outra lista. Caso ambas as listas tenham mesmo valor, retorna FALSE. Considere vetor vazio com soma zero.
    Deve ser implementada usando map/filter/reduce
*/
function maior(v1, v2) {
       
  const soma = (vetor) => vetor.reduce((acc, val) => acc + val, 0);

  const soma1 = soma(v1);
  const soma2 = soma(v2);

  if (soma1 > soma2) {
      return v1;
  } else if (soma2 > soma1) {
      return v2;
  } else {
      return false;
  }

}
